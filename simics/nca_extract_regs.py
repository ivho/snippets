#!/usr/bin/python

"""
Take a RTE header file and extract bit field names to dml style syntax
"""

import sys
import pprint 
import xml.dom.minidom
from xml.dom.minidom import Node


def parse_error(c=""):
    print "parse error %s" % c
    sys.exit(1)

def get_comment_regions(f, out, pout):
    r=[]
    p=f.read()
    last = 0
    while True:
        start=p.find('/*!', last)
        if start != -1:
            start+=3
            end=p.find('*/', start)
            if end == -1:
                print "parse error"
                sys.exit(-1)        
            tmp=p[start:end].split('\n')
            
# the first 3 lines look like:
#/*! @struct ncp_nca_config_init_reg_v3_t
# *  @brief NCA Config and Initialization Parameters
# *  @details This register defines some AXI burst beat numbers, enables, and soft reset signals
            pre=" *" +tmp[0]+"\n"+tmp[1]
            postamble=""
            xml=""
            end_of_xml = False
            for s in tmp[2:]:
                if s.find("@details") != -1:
                    pre += "\n" + s
                    continue
                # check for multiline details...
                if not s.startswith(" * "):
#                    print "SKIPPING... <%s>" % s        
                    pre += "\n" + s
                    continue
                if end_of_xml:
                    postamble += "\n" + s
                    continue

                if s.startswith(" * Applies to:"):                    
                    end_of_xml = True
                    postamble=s
                    continue

                xml += s[3:]
            parse_xml(xml, out, pout, pre, postamble)
            last = end
        else:
            break

def parse_xml(str, f, pf, pre, postamble):
    try:
        doc = xml.dom.minidom.parseString(str)
    except xml.parsers.expat.ExpatError:
        print "XML ERROR"
        print str
        sys.exit(1)

    trs=doc.getElementsByTagName("tr")


    #parse the struct/register name in trs[0]
    struct=trs[0].getElementsByTagName("td")[0].childNodes[0].data    
    full_struct=trs[0].getElementsByTagName("td")[0].childNodes[0].data.strip()
    skips="struct"
    if not full_struct.startswith(skips):
        parse_error("<%s>:<%s>" %(skips, full_struct))
    skipe="_t\\n"
    if not full_struct.endswith(skipe):
        parse_error("<%s>:<%s>" %(skipe, full_struct))
    struct_name=full_struct[len(skips)+1:len(full_struct)-len(skipe)].strip()    
    if not struct_name.startswith("ncp_nca_cfg_pio"):
        print "skipping", struct_name
        return
    f.write("\n\n/*\n"
            + pre 
            + " * " + full_struct + "\n *\n"
            + postamble + 
            "\n*/\n")
#    f.write("\n\n// - %s\n\n"  % full_struct)
    f.write("/* -- commented by default -- \n")    
    f.write("register %s {\n"  % struct_name.upper())
    pf.write("""%s = dev_util.Register_BE(
(nca, 'regs', %s), 
size = 4,
bitfield = dev_util.Bitfield_BE({
""" % (struct_name.upper(), struct_name.upper()+"_OFFSET"))
             
    #trs[1] is the column descriptions
    #the rest should be fields
    for tr in trs[2:]:
        tds=tr.getElementsByTagName("td")
        v=tds[0].childNodes[0].data.strip()
        check="@param"
        print v, type(v), type(v.encode())
        if not v.encode().startswith(check):
            parse_error(check+":"+ v)
        fname=tds[0].childNodes[0].data[len(check)+1:].strip()
        width=int(tds[1].childNodes[0].data)
        start=int(tds[2].childNodes[0].data)
        comment=tds[3].childNodes[0].data
        template = "unimplemented"
        if fname.encode().startswith("reserved"):
            template = "must_write_zero"

        f.write(" field %s[%d:%d] is (%s) \"%s\";\n" % (fname, start+width-1, start, template, comment.strip()))
        pf.write("\"%s\":(%d,%d),\n" % (fname, start+width-1, start))
    #end of register
    f.write("}\n")
    pf.write("}))\n")
    f.write("*/\n")

if __name__ == "__main__":
    f=file(sys.argv[1])
    out=file(sys.argv[2], "w")

    out.write("//\n")
    out.write("//autogenerated from %s\n" % sys.argv[1])
    out.write("//\n" )
    out.write("\n" )
             
    pout=file("nca.py", "w")
    get_comment_regions(f, out, pout)

